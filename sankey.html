<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Across Live Flow - Sankey Diagram</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
    <style>
        :root {
            --bg-primary: #0f1419;
            --bg-secondary: #1a1f26;
            --bg-card: rgba(30, 37, 46, 0.7);
            --accent: #6feac5;
            --accent-secondary: #44d7a8;
            --text-primary: #e7e9ea;
            --text-secondary: #8b98a5;
            --status-pending: #f7931a;
            --status-filled: #00d395;
            --border: rgba(255, 255, 255, 0.08);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 24px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header h1 span {
            color: var(--accent);
        }

        .live-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .live-dot {
            width: 10px;
            height: 10px;
            background: var(--status-filled);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                box-shadow: 0 0 0 0 rgba(0, 211, 149, 0.4);
            }

            50% {
                opacity: 0.8;
                box-shadow: 0 0 0 8px rgba(0, 211, 149, 0);
            }
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 24px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px 24px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stat-item .label {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-item .value {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent);
        }

        /* Sankey Container */
        .sankey-container {
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 24px;
            position: relative;
            overflow: hidden;
            min-height: 600px;
        }

        .sankey-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent), var(--accent-secondary));
        }

        #sankey-diagram {
            width: 100%;
            height: 600px;
        }

        /* Sankey Styles */
        .node rect {
            fill-opacity: 0.9;
            stroke: rgba(255, 255, 255, 0.2);
            stroke-width: 1px;
            transition: fill-opacity 0.2s;
        }

        .node rect:hover {
            fill-opacity: 1;
        }

        .node text {
            fill: var(--text-primary);
            font-size: 12px;
            font-weight: 500;
        }

        .link {
            fill: none;
            stroke-opacity: 0.6;
            transition: stroke-opacity 0.2s;
        }

        .link:hover {
            stroke-opacity: 0.9;
        }

        .link.flash {
            animation: linkFlash 1.5s ease-out;
        }

        @keyframes linkFlash {
            0% {
                stroke-opacity: 1;
            }

            25% {
                stroke-opacity: 0.7;
            }

            50% {
                stroke-opacity: 1;
            }

            75% {
                stroke-opacity: 0.7;
            }

            100% {
                stroke-opacity: 0.6;
            }
        }

        /* Particle animation */
        .particle {
            fill: var(--accent);
            filter: drop-shadow(0 0 4px var(--accent));
        }

        /* Empty state */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 400px;
            color: var(--text-secondary);
            gap: 16px;
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            opacity: 0.5;
        }

        /* Footer */
        .footer {
            margin-top: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-secondary);
            font-size: 13px;
        }

        .footer a {
            color: var(--accent);
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip .chain-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .tooltip .volume {
            color: var(--accent);
        }

        /* Node labels */
        .node-label {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .node-label img {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        /* Loading */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 400px;
            color: var(--text-secondary);
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 12px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 16px;
                text-align: center;
            }

            .stats-bar {
                justify-content: center;
            }

            #sankey-diagram {
                height: 400px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1>
                <img src="assets/across_logo.png" alt="Across" style="height: 28px; vertical-align: middle;">
                <span>Across</span>Live Flow
            </h1>
            <div style="display: flex; align-items: center; gap: 20px;">
                <a href="index.html"
                    style="display: flex; align-items: center; gap: 8px; background: rgba(111, 234, 197, 0.1); border: 1px solid var(--accent); color: var(--accent); padding: 8px 16px; border-radius: 8px; text-decoration: none; font-size: 14px; font-weight: 500; transition: all 0.2s;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" />
                        <path d="M3 9h18" />
                        <path d="M9 21V9" />
                    </svg>
                    Deposits Monitor
                </a>
                <a href="https://0xlong.github.io/across-analytics/preset_dashboard.html"
                    style="display: flex; align-items: center; gap: 8px; background: rgba(111, 234, 197, 0.1); border: 1px solid var(--accent); color: var(--accent); padding: 8px 16px; border-radius: 8px; text-decoration: none; font-size: 14px; font-weight: 500; transition: all 0.2s;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="7" height="7" />
                        <rect x="14" y="3" width="7" height="7" />
                        <rect x="14" y="14" width="7" height="7" />
                        <rect x="3" y="14" width="7" height="7" />
                    </svg>
                    Dashboard
                </a>
                <div class="live-indicator">
                    <div class="live-dot"></div>
                    <span id="connection-status">Connecting...</span>
                </div>
            </div>
        </header>

        <!-- Stats Bar -->
        <div class="stats-bar">
            <div class="stat-item">
                <span class="label">Active Chains</span>
                <span class="value" id="stat-chains">-</span>
            </div>
            <div class="stat-item">
                <span class="label">Volume (5min)</span>
                <span class="value" id="stat-volume">-</span>
            </div>
            <div class="stat-item">
                <span class="label">Transactions (5min)</span>
                <span class="value" id="stat-txs">-</span>
            </div>
            <div class="stat-item">
                <span class="label">Top Route (by higest volume USD in 5MIN)</span>
                <span class="value" id="stat-top-route">-</span>
            </div>
        </div>

        <!-- Sankey Diagram -->
        <div class="sankey-container">
            <div id="sankey-diagram" class="loading">Loading flow data</div>
        </div>

        <!-- Tooltip -->
        <div class="tooltip" id="tooltip"></div>

        <!-- Footer -->
        <div class="footer" style="justify-content: center;">
            <span>Last updated: <span id="last-update">-</span></span>
        </div>
    </div>

    <script>
        // Configuration
        const API_URL = 'https://app.across.to/api/deposits';
        const POLL_INTERVAL = 2000; // 2 seconds
        const TIME_WINDOW = 2 * 60 * 1000; // 5 minutes in ms
        const PARTICLE_DURATION = 1000; // ms for particle to travel

        // State
        let depositsCache = new Map(); // depositId -> deposit
        let tokenPrices = {};
        let contractToToken = {};
        let isFirstLoad = true;

        // Chain configuration
        const CHAINS = {
            1: { name: 'Ethereum', logo: 'assets/chains/ethereum.png', color: '#627EEA' },
            10: { name: 'Optimism', logo: 'assets/chains/optimism.png', color: '#FF0420' },
            56: { name: 'BNB Chain', logo: 'assets/chains/bnb.png', color: '#F0B90B' },
            130: { name: 'Unichain', logo: 'assets/chains/unichain.png', color: '#FF007A' },
            137: { name: 'Polygon', logo: 'assets/chains/polygon.png', color: '#8247E5' },
            324: { name: 'zkSync', logo: 'assets/chains/zksync.png', color: '#8C8DFC' },
            480: { name: 'World Chain', logo: 'assets/chains/world.png', color: '#00D395' },
            999: { name: 'Hyperliquid', logo: 'assets/chains/hyperliquid.png', color: '#00FFAA' },
            1135: { name: 'Lisk', logo: 'assets/chains/lisk.png', color: '#0033FF' },
            1868: { name: 'Soneium', logo: 'assets/chains/soneium.png', color: '#FF6B00' },
            8453: { name: 'Base', logo: 'assets/chains/base.png', color: '#0052FF' },
            34443: { name: 'Mode', logo: 'assets/chains/mode.png', color: '#DFFE00' },
            42161: { name: 'Arbitrum', logo: 'assets/chains/arbitrum.png', color: '#28A0F0' },
            57073: { name: 'Ink', logo: 'assets/chains/ink.png', color: '#7B3FE4' },
            59144: { name: 'Linea', logo: 'assets/chains/linea.png', color: '#61DFFF' },
            81457: { name: 'Blast', logo: 'assets/chains/blast.png', color: '#FCFC03' },
            534352: { name: 'Scroll', logo: 'assets/chains/scroll.png', color: '#FFEEDA' },
            7777777: { name: 'Zora', logo: 'assets/chains/zora.png', color: '#5B5BD6' },
            34268394551451: { name: 'Solana', logo: 'assets/chains/solana.png', color: '#9945FF' }
        };

        // Token to CoinGecko ID mapping
        const TOKEN_TO_COINGECKO = {
            'WETH': 'ethereum',
            'ETH': 'ethereum',
            'USDC': 'usd-coin',
            'USDC.E': 'usd-coin',
            'USDT': 'tether',
            'WBTC': 'wrapped-bitcoin',
            'DAI': 'dai',
            'ACX': 'across-protocol',
            'UMA': 'uma',
            'BAL': 'balancer',
            'BNB': 'binancecoin'
        };

        // Initialize
        async function init() {
            await Promise.all([
                loadTokenMetadata(),
                fetchTokenPrices()
            ]);

            // Start polling
            await fetchDeposits();
            setInterval(fetchDeposits, POLL_INTERVAL);
            setInterval(fetchTokenPrices, 60000);
        }

        // Load token metadata from CSV
        async function loadTokenMetadata() {
            try {
                const response = await fetch('assets/token_metadata.csv');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const text = await response.text();
                const lines = text.trim().split(/\r?\n/);
                for (let i = 1; i < lines.length; i++) {
                    const parts = lines[i].split(',');
                    if (parts.length >= 5) {
                        const symbol = parts[2].trim();
                        const address = parts[3].trim().toLowerCase();
                        const decimals = parseInt(parts[4].trim()) || 18;
                        if (address && address !== '0x0000000000000000000000000000000000000000') {
                            contractToToken[address] = { symbol, decimals };
                        }
                    }
                }
                console.log('Loaded token metadata:', Object.keys(contractToToken).length);
            } catch (error) {
                console.error('Failed to load token metadata:', error);
            }
        }

        // Fetch token prices from CoinGecko
        async function fetchTokenPrices() {
            try {
                const ids = [...new Set(Object.values(TOKEN_TO_COINGECKO))].join(',');
                const url = `https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=usd`;
                const response = await fetch(url);
                const data = await response.json();

                for (const [symbol, cgId] of Object.entries(TOKEN_TO_COINGECKO)) {
                    if (data[cgId]?.usd) {
                        tokenPrices[symbol.toUpperCase()] = data[cgId].usd;
                    }
                }
                console.log('Updated prices:', tokenPrices);
            } catch (error) {
                console.error('Failed to fetch prices:', error);
            }
        }

        // Get token symbol from deposit
        function getTokenSymbol(deposit) {
            const assetSymbol = deposit.assetSymbol;
            if (assetSymbol && assetSymbol.length <= 10 && !assetSymbol.startsWith('0x')) {
                return assetSymbol.toUpperCase();
            }

            const address = (deposit.assetAddr || deposit.inputToken || '').toLowerCase();
            if (address && contractToToken[address]) {
                return contractToToken[address].symbol.toUpperCase();
            }

            return 'UNKNOWN';
        }

        // Get token decimals
        function getTokenDecimals(deposit) {
            const address = (deposit.assetAddr || deposit.inputToken || '').toLowerCase();
            if (address && contractToToken[address]) {
                return contractToToken[address].decimals;
            }

            const symbol = getTokenSymbol(deposit);
            if (symbol.includes('USDC') || symbol.includes('USDT')) return 6;
            if (symbol.includes('WBTC')) return 8;

            return deposit.assetDecimals || 18;
        }

        // Calculate USD value
        function getUsdValue(deposit) {
            const symbol = getTokenSymbol(deposit);
            const price = tokenPrices[symbol] || tokenPrices[symbol.split('.')[0]];
            if (!price) return 0;

            const decimals = getTokenDecimals(deposit);
            const amount = parseFloat(deposit.inputAmount || deposit.outputAmount || '0');
            return (amount / Math.pow(10, decimals)) * price;
        }

        // Format USD
        function formatUsd(value) {
            if (value >= 1000000) return '$' + (value / 1000000).toFixed(2) + 'M';
            if (value >= 1000) return '$' + (value / 1000).toFixed(1) + 'K';
            return '$' + value.toFixed(0);
        }

        // Get chain info
        function getChainInfo(chainId) {
            return CHAINS[chainId] || { name: `Chain ${chainId}`, logo: 'assets/chains/ethereum.png', color: '#627EEA' };
        }

        // Fetch deposits
        async function fetchDeposits() {
            try {
                const response = await fetch(`${API_URL}?limit=200`);
                const data = await response.json();

                const deposits = data.deposits || data;
                const now = Date.now();
                const cutoff = now - TIME_WINDOW;

                // Track new deposits for particle animation
                const newDeposits = [];

                deposits.forEach(d => {
                    const timestamp = new Date(d.depositBlockTimestamp).getTime();
                    if (timestamp >= cutoff) {
                        if (!depositsCache.has(d.depositId)) {
                            newDeposits.push(d);
                        }
                        depositsCache.set(d.depositId, { ...d, _timestamp: timestamp });
                    }
                });

                // Prune old deposits
                for (const [id, d] of depositsCache) {
                    if (d._timestamp < cutoff) {
                        depositsCache.delete(id);
                    }
                }

                // Update UI
                updateStatus('Live');
                updateDiagram(newDeposits);
                updateStats();
                document.getElementById('last-update').textContent = new Date().toLocaleTimeString();

                isFirstLoad = false;

            } catch (error) {
                console.error('Fetch error:', error);
                updateStatus('Error - Retrying...');
            }
        }

        function updateStatus(status) {
            document.getElementById('connection-status').textContent = status;
        }

        // Build Sankey data from cache
        // Split each chain into source (left) and target (right) to avoid circular links
        function buildSankeyData() {
            const flows = new Map(); // "origin->dest" => { value, count }
            const sourceChains = new Set(); // chains that appear as origin
            const targetChains = new Set(); // chains that appear as destination

            for (const [, deposit] of depositsCache) {
                const origin = deposit.originChainId;
                const dest = deposit.destinationChainId;
                if (!origin || !dest || origin === dest) continue;

                sourceChains.add(origin);
                targetChains.add(dest);

                const key = `${origin}->${dest}`;
                const usdValue = getUsdValue(deposit);

                if (!flows.has(key)) {
                    flows.set(key, { value: 0, count: 0 });
                }
                const flow = flows.get(key);
                flow.value += usdValue;
                flow.count += 1;
            }

            // Build nodes - source chains on left, target chains on right
            const nodes = [];

            // Add source nodes (left side) with "src_" prefix
            for (const chainId of sourceChains) {
                nodes.push({
                    id: `src_${chainId}`,
                    chainId: chainId,
                    name: getChainInfo(chainId).name,
                    logo: getChainInfo(chainId).logo,
                    color: getChainInfo(chainId).color,
                    side: 'source'
                });
            }

            // Add target nodes (right side) with "tgt_" prefix
            for (const chainId of targetChains) {
                nodes.push({
                    id: `tgt_${chainId}`,
                    chainId: chainId,
                    name: getChainInfo(chainId).name,
                    logo: getChainInfo(chainId).logo,
                    color: getChainInfo(chainId).color,
                    side: 'target'
                });
            }

            // Build links - from src_ nodes to tgt_ nodes
            const links = [];
            for (const [key, flow] of flows) {
                const [origin, dest] = key.split('->').map(Number);
                if (flow.value > 0 || flow.count > 0) {
                    links.push({
                        source: `src_${origin}`,
                        target: `tgt_${dest}`,
                        value: Math.max(1, flow.value), // Minimum value of 1 for visibility
                        count: flow.count,
                        originId: origin,
                        destId: dest
                    });
                }
            }

            return { nodes, links };
        }

        // D3 Sankey diagram
        let svg, sankey, sankeyGroup, linkGroup, nodeGroup, particleGroup, labelGroup;
        let currentData = { nodes: [], links: [] };

        function initSankey() {
            const container = document.getElementById('sankey-diagram');
            container.innerHTML = '';
            container.classList.remove('loading');

            const width = container.clientWidth;
            const height = container.clientHeight || 600;

            svg = d3.select('#sankey-diagram')
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('overflow', 'visible');

            // Add defs for gradients
            const defs = svg.append('defs');

            sankeyGroup = svg.append('g');

            linkGroup = sankeyGroup.append('g').attr('class', 'links');
            nodeGroup = sankeyGroup.append('g').attr('class', 'nodes');
            particleGroup = sankeyGroup.append('g').attr('class', 'particles');
            labelGroup = sankeyGroup.append('g').attr('class', 'labels');

            sankey = d3.sankey()
                .nodeId(d => d.id)
                .nodeWidth(28) // Slightly wider nodes
                .nodePadding(25) // Less padding but still separated
                .extent([[140, 20], [width - 140, height - 40]]);
        }

        // Create gradient for a link
        function createLinkGradient(svg, link, index) {
            const gradientId = `gradient-${link.originId}-${link.destId}`;
            const sourceColor = getChainInfo(link.originId).color;
            const targetColor = getChainInfo(link.destId).color;

            let gradient = svg.select(`#${gradientId}`);
            if (gradient.empty()) {
                gradient = svg.select('defs').append('linearGradient')
                    .attr('id', gradientId)
                    .attr('gradientUnits', 'userSpaceOnUse');
            }

            gradient
                .attr('x1', link.source.x1)
                .attr('y1', 0)
                .attr('x2', link.target.x0)
                .attr('y2', 0);

            gradient.selectAll('stop').remove();
            gradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', sourceColor);
            gradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', targetColor);

            return `url(#${gradientId})`;
        }

        function updateDiagram(newDeposits = []) {
            const data = buildSankeyData();

            if (data.nodes.length === 0) {
                const container = document.getElementById('sankey-diagram');
                if (!container.querySelector('.empty-state')) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                            </svg>
                            <p>Waiting for deposit flow data...</p>
                        </div>
                    `;
                }
                return;
            }

            if (!svg) {
                initSankey();
            }

            // Update sankey layout
            const { nodes, links } = sankey({
                nodes: data.nodes.map(d => ({ ...d })),
                links: data.links.map(d => ({ ...d }))
            });

            currentData = { nodes, links };

            // Update links - use stroke-based rendering which handles stacking properly
            const linkSelection = linkGroup.selectAll('.link')
                .data(links, d => `${d.originId}->${d.destId}`);

            linkSelection.exit()
                .transition()
                .duration(500)
                .style('stroke-opacity', 0)
                .remove();

            const linkEnter = linkSelection.enter()
                .append('path')
                .attr('class', 'link')
                .attr('d', d3.sankeyLinkHorizontal())
                .style('fill', 'none')
                .style('stroke-width', d => Math.max(1, d.width))
                .style('stroke-opacity', 0.6);

            // Apply gradient stroke to all links
            const allLinks = linkSelection.merge(linkEnter);

            allLinks.each(function (d) {
                const gradientUrl = createLinkGradient(svg, d);
                d3.select(this).style('stroke', gradientUrl);
            });

            allLinks.transition()
                .duration(500)
                .attr('d', d3.sankeyLinkHorizontal())
                .style('stroke-width', d => Math.max(1, d.width));

            // Link hover
            linkGroup.selectAll('.link')
                .on('mouseenter', function (event, d) {
                    d3.select(this).style('stroke-opacity', 0.9);
                    showTooltip(event, `
                        <div class="chain-name">${getChainInfo(d.originId).name} → ${getChainInfo(d.destId).name}</div>
                        <div class="volume">${formatUsd(d.value)}</div>
                        <div>${d.count} transactions</div>
                    `);
                })
                .on('mouseleave', function () {
                    d3.select(this).style('stroke-opacity', 0.6);
                    hideTooltip();
                });

            // Volume labels - only show for significant flows (>$100)
            const significantLinks = links.filter(d => d.value >= 100);
            const labelSelection = labelGroup.selectAll('.link-label')
                .data(significantLinks, d => `${d.originId}->${d.destId}`);

            labelSelection.exit().remove();

            const labelEnter = labelSelection.enter()
                .append('text')
                .attr('class', 'link-label')
                .style('fill', '#ffffff')
                .style('font-size', '10px')
                .style('font-weight', '600')
                .style('text-anchor', 'middle')
                .style('pointer-events', 'none')
                .style('text-shadow', '0 1px 3px rgba(0,0,0,0.8)');

            labelSelection.merge(labelEnter)
                .attr('x', d => (d.source.x1 + d.target.x0) / 2)
                .attr('y', d => (d.y0 + d.y1) / 2 + 4)
                .text(d => formatUsd(d.value));

            // Update nodes
            const nodeSelection = nodeGroup.selectAll('.node')
                .data(nodes, d => d.id);

            nodeSelection.exit()
                .transition()
                .duration(500)
                .style('opacity', 0)
                .remove();

            // Debug: log nodes
            console.log('Rendering nodes:', nodes.length, nodes.map(n => ({ id: n.id, x0: n.x0, y0: n.y0, y1: n.y1 })));

            const nodeEnter = nodeSelection.enter()
                .append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.x0},${d.y0})`);

            nodeEnter.append('rect')
                .attr('height', d => Math.max(20, d.y1 - d.y0)) // Minimum height of 20
                .attr('width', sankey.nodeWidth())
                .attr('fill', d => d.color || '#6feac5')
                .attr('rx', 4);

            // Source nodes: label on left, Target nodes: label on right
            nodeEnter.append('image')
                .attr('x', d => d.side === 'source' ? -28 : sankey.nodeWidth() + 8)
                .attr('y', d => Math.max(20, d.y1 - d.y0) / 2 - 10)
                .attr('width', 20)
                .attr('height', 20)
                .attr('href', d => d.logo);

            nodeEnter.append('text')
                .attr('x', d => d.side === 'source' ? -32 : sankey.nodeWidth() + 32)
                .attr('y', d => Math.max(20, d.y1 - d.y0) / 2)
                .attr('dy', '0.35em')
                .attr('text-anchor', d => d.side === 'source' ? 'end' : 'start')
                .text(d => d.name)
                .style('fill', '#e7e9ea'); // Ensure text is visible

            const nodeMerge = nodeSelection.merge(nodeEnter);

            nodeMerge.transition()
                .duration(500)
                .attr('transform', d => `translate(${d.x0},${d.y0})`);

            nodeMerge.select('rect')
                .transition()
                .duration(500)
                .attr('height', d => Math.max(20, d.y1 - d.y0));

            nodeMerge.select('image')
                .attr('x', d => d.side === 'source' ? -28 : sankey.nodeWidth() + 8)
                .attr('y', d => Math.max(20, d.y1 - d.y0) / 2 - 10);

            nodeMerge.select('text')
                .attr('x', d => d.side === 'source' ? -32 : sankey.nodeWidth() + 32)
                .attr('y', d => Math.max(20, d.y1 - d.y0) / 2)
                .attr('text-anchor', d => d.side === 'source' ? 'end' : 'start');

            // Animate particles for new deposits
            if (!isFirstLoad) {
                newDeposits.forEach(deposit => {
                    animateParticle(deposit);
                });
            }
        }

        // Animate a particle along a link and flash the link
        function animateParticle(deposit) {
            const origin = deposit.originChainId;
            const dest = deposit.destinationChainId;

            // Find the corresponding link data
            const link = currentData.links.find(l => l.originId === origin && l.destId === dest);
            if (!link) return;

            // Flash the link path
            linkGroup.selectAll('.link')
                .filter(d => d.originId === origin && d.destId === dest)
                .each(function () {
                    const el = d3.select(this);
                    el.classed('flash', false);
                    // Force reflow to restart animation
                    void this.offsetWidth;
                    el.classed('flash', true);
                });

            const usdValue = getUsdValue(deposit);
            const particleSize = Math.min(12, Math.max(4, Math.sqrt(usdValue / 100)));

            // Create path for particle to follow
            const path = d3.sankeyLinkHorizontal()(link);

            const particle = particleGroup.append('circle')
                .attr('class', 'particle')
                .attr('r', particleSize)
                .style('fill', getChainInfo(origin).color)
                .style('filter', `drop-shadow(0 0 ${particleSize}px ${getChainInfo(origin).color})`);

            // Get path length for animation
            const pathNode = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            pathNode.setAttribute('d', path);
            const pathLength = pathNode.getTotalLength();

            // Animate along path
            particle.transition()
                .duration(PARTICLE_DURATION)
                .ease(d3.easeLinear)
                .attrTween('transform', function () {
                    return function (t) {
                        const point = pathNode.getPointAtLength(t * pathLength);
                        return `translate(${point.x},${point.y})`;
                    };
                })
                .on('end', function () {
                    d3.select(this)
                        .transition()
                        .duration(300)
                        .style('opacity', 0)
                        .remove();
                });
        }

        // Tooltip
        function showTooltip(event, html) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = html;
            tooltip.classList.add('visible');
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        // Update stats
        function updateStats() {
            const data = buildSankeyData();

            // Active chains
            document.getElementById('stat-chains').textContent = data.nodes.length;

            // Total volume
            const totalVolume = data.links.reduce((sum, l) => sum + l.value, 0);
            document.getElementById('stat-volume').textContent = formatUsd(totalVolume);

            // Transaction count
            const txCount = data.links.reduce((sum, l) => sum + l.count, 0);
            document.getElementById('stat-txs').textContent = txCount;

            // Top route
            if (data.links.length > 0) {
                const topLink = data.links.reduce((max, l) => l.value > max.value ? l : max, data.links[0]);
                const originName = getChainInfo(topLink.originId).name;
                const destName = getChainInfo(topLink.destId).name;
                document.getElementById('stat-top-route').textContent = `${originName} → ${destName}`;
            } else {
                document.getElementById('stat-top-route').textContent = '-';
            }
        }

        // Handle resize
        window.addEventListener('resize', () => {
            if (svg) {
                const container = document.getElementById('sankey-diagram');
                const width = container.clientWidth;
                const height = container.clientHeight || 600;

                svg.attr('width', width).attr('height', height);
                sankey.extent([[140, 20], [width - 140, height - 40]]);
                updateDiagram();
            }
        });

        // Start
        init();
    </script>
</body>

</html>
